// Bit Masking Easy Reference Chart 
// Type/# _______________________________________________________________________________________
// Byte   |0              |1                    |2                      |3                      |
//        |-------------------------------------------------------------------------------------|
// Nibble |0      |1      |2        |3          |4          |5          |6          |7          |
//        |-------------------------------------------------------------------------------------|
// 2 Bits |0  |1  |2  |3  |4  |5    |6    |7    |8    |9    |10   |11   |12   |13   |14   |15   |
//        |-------------------------------------------------------------------------------------|
// Bits   |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|
//        |-------------------------------------------------------------------------------------|
//
// All variables haves 4 Bytes, 8 Nibbles, 16 2Bits and/or 32 bits.
// Byte range 0-255
// Nibble range 0-15
// 2Bit range 0-3
// bit range 0 or 1
//
// One Nibble Translated:
// Binary = Decimal
// 0000   = 0
// 0001   = 1
// 0010   = 2
// 0011   = 3
// 0100   = 4
// 0101   = 5
// 0110   = 6
// 0111   = 7
// 1000   = 8
// 1001   = 9
// 1010   = 10
// 1011   = 11
// 1100   = 12
// 1101   = 13
// 1110   = 14
// 1111   = 15
//
// Note: Therefore Setting Bits 4-7 to 1 will make Nibble 1 15.
//       Therefore Setting Bits 0-7 will make Nibble 0 & 1 15, and Byte 0 255
//
// Linear Quest Var:
// BYTE:
//     0: Step1.
//     1: Step2.
//     ...
//     255: Step256.
// Nibble:
//     0: Step1.
//     1: Step2.
//     ...
//     14: Step16.
//
// Non-linear Quest Var:
//       BYTE: Main Quest Line
//           NIBBLE: Current-Step
//               BIT: Step
//               BIT: Step
//               BIT: Step
//               BIT: Step
//           NIBBLE: Sub-Quest
//               0-15: Step 1-16
//
// Non-linear w/linear check
//  - You can set Bits and Total the 2 bit, Nibble or Byte
//
//  Example #1:
//      Bit 4: Step (set)
//      Bit 5: Step (set)
//      Bit 6: Step (set)
//      Bit 7: Step (set)
//      =
//      Nibble 1: 15
//
//  Therefore, Checking progress can be determined by total:
//      0110   = 6 is Bit 5 & 6 set on Nibble 1.
//      0101   = 5 is Bit 5 & 7 set on Nibble 1.
//  Thus we can know were a player is in a non-linear quest.
//
// Dev Note: There are plans to make 64 bit quest variables.

017-9.gat,22,30,0|script|BitMaskDebug|175,
{

    mes "[Bit Mask Debug]";
    mes "\"What you wyou like to do?\"";
    menu
        "Shift Byte 1.", L_ByteShift,
        "Shift Nibble 0.", L_NibbleShift,
        "Shift Bit 4.", L_BitShift,
        "Done.", L_Close;

L_ByteShift:
    set @debugexample, ((DEBUGEXAMPLE & BYTE_1_MASK) >> BYTE_1_SHIFT);
    message strcharinfo(0), @debugexample;
    if (@debugexample == 175) 
        goto L_ByteUnset;

    mes "Byte 1 set to 175";
    set DEBUGEXAMPLE, (DEBUGEXAMPLE & ~(BYTE_1_MASK) | (175 << BYTE_1_SHIFT));
    goto L_Close;

L_ByteUnset:
    mes "Byte 1 set to 0";
    set DEBUGEXAMPLE, (DEBUGEXAMPLE & ~(BYTE_1_MASK) | (0 << BYTE_1_SHIFT));
    goto L_Close;

L_NibbleShift:
    set @debugexample, ((DEBUGEXAMPLE & NIBBLE_0_MASK) >> NIBBLE_0_SHIFT);
    message strcharinfo(0), @debugexample;
    if (@debugexample == 10) 
        goto L_NibbleUnset;

    mes "Nibble 0 set to 10";
    set DEBUGEXAMPLE, (DEBUGEXAMPLE & ~(NIBBLE_0_MASK) | (10 << NIBBLE_0_SHIFT));
    goto L_Close;

L_NibbleUnset:
    mes "Nibble 0 set to 0";
    set DEBUGEXAMPLE, (DEBUGEXAMPLE & ~(NIBBLE_0_MASK) | (0 << NIBBLE_0_SHIFT));
    goto L_Close;

L_BitShift:
    set @debugexample, ((DEBUGEXAMPLE & NIBBLE_1_MASK) >> NIBBLE_1_SHIFT);
    message strcharinfo(0), @debugexample;
    if (DEBUGEXAMPLE & (1 << 4))
        goto L_BitUnset; 

    mes "Bit 4 Set to 1";
    set DEBUGEXAMPLE, DEBUGEXAMPLE | (1 << 4);
    goto L_Close;

L_BitUnset:
    mes "Bit 4 Set to 0";
    set DEBUGEXAMPLE, DEBUGEXAMPLE &~ (1 << 4);
    goto L_Close;

L_Close:
    set @debugexample, 0;
    close;
}
